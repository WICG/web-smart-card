<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        group: "wicg",
        specStatus: "unofficial",
        editors: [{
          name: "Daniel d'Andrada",
          company: "Google",
          companyURL: "https://google.com/",
          mailto: "dandrader@google.com",
        }],
        github: {
          branch: "main",
          repoURL: "WICG/web-smart-card",
        },
        xref: ["dom", "hr-time-3", "html", "infra", "permissions-policy", "webidl"],
      };
    </script>
  </head>
  <body>
    <h1 id="title">Web Smart Card API</h1>
    <section id='abstract'>
      <p>
        The objective of this API is to enable smart card (PC/SC) applications
        to move to the Web Platform. It gives them access to the PC/SC
        implementation (and card reader drivers) available in the host OS.

        There is also a companion <a href="https://github.com/WICG/web-smart-card/blob/main/README.md">explainer</a> document.
    </section>
      </p>
    </section>
    <section id='sotd'>
      <!-- This section is filled automatically by ReSpec. -->
    </section>

    <section data-dfn-for="Navigator">
      <h2>Extensions to the {{Navigator}} interface</h2>
      <pre class="idl">
        [Exposed=Window, SecureContext]
        partial interface Navigator {
          [SameObject] readonly attribute SmartCardResourceManager smartCard;
        };
      </pre>

      <h3><dfn>smartCard</dfn> attribute</h3>
      <p>When getting, the {{Navigator/smartCard}} attribute always returns the same
      instance of the {{SmartCardResourceManager}} object.</p>
    </section>

    <section data-dfn-for="WorkerNavigator">
      <h2>Extensions to the {{WorkerNavigator}} interface</h2>
      <pre class="idl">
        [Exposed=(DedicatedWorker, SharedWorker), SecureContext]
        partial interface WorkerNavigator {
          [SameObject] readonly attribute SmartCardResourceManager smartCard;
        };
      </pre>

      <h3><dfn>smartCard</dfn> attribute</h3>
      <p>When getting, the {{Navigator/smartCard}} attribute always returns the same
      instance of the {{SmartCardResourceManager}} object.</p>
    </section>

    <section data-dfn-for="SmartCardResourceManager">
      <h2><dfn>SmartCardResourceManager</dfn> interface</h2>
      <pre class="idl">
        [Exposed=(DedicatedWorker, SharedWorker, Window), SecureContext]
        interface SmartCardResourceManager {
          Promise&lt;SmartCardContext&gt; establishContext();
        };
      </pre>
      <p>Methods on this interface complete asynchronously, queuing
      work on the <dfn>smart card task source</dfn>.</p>
      <section>
        <h3><dfn>establishContext()</dfn> method</h3>
        <p>Requests a PC/SC context from the platform's PC/SC stack.</p>
        The {{SmartCardResourceManager/establishContext()}} method steps are:
        <ol>
          <li>
            If [=this=]'s [=relevant global object=]'s [=associated Document=] is
            not [=allowed to use=] the [=policy-controlled feature=] named
            "[=policy-controlled feature/smart-card=]", [=exception/throw=] a
            "{{SecurityError}}" {{DOMException}}.
          </li>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>Run the following steps [=in parallel=]:
          <ol>
            <li>Let |resourceManager:RESOURCEMANAGER| be a new instance of the
              platform's [[PCSC5]] `RESOURCEMANAGER` class.</li>
            <li>Invoke the `EstablishContext` method of |resourceManager| with
              a "system" `Scope` parameter.</li>
            <li>If the returned `RESPONSECODE` is not `SCARD_S_SUCCESS`, perform
              the following steps:
              <ol>
                <li>Destroy |resourceManager|.</li>
                <li>[=Queue a global task=] on the [=relevant global object=] of
                  [=this=] using the [=smart card task source=] to [=reject=]
                  |promise| with a {{SmartCardError/corresponding}}
                  [=exception=].</li>
              </ol>
            </li>
            <li>Otherwise, perform the following steps:
              <ol>
                <li>Let |context:SmartCardContext| be a [=new=]
                  {{SmartCardContext}} whose
                  {{SmartCardContext/[[resourceManager]]}} internal slot is set
                to |resourceManager|.</li>
                <li>[=Queue a global task=] on the [=relevant global object=]
                  of [=this=] using the [=smart card task source=] to
                  [=resolve=] |promise| with |context|.</li>
              </ol>
            </li>
          </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
      </section>
    </section>

    <section data-dfn-for="SmartCardContext">
      <h2><dfn>SmartCardContext</dfn> interface</h2>
      <p>A context for communicating with the PC/SC resource manager.</p>
      <pre class="idl">
        [Exposed=(DedicatedWorker, SharedWorker, Window), SecureContext]
        interface SmartCardContext {
          Promise&lt;sequence&lt;DOMString&gt;&gt; listReaders();

          Promise&lt;sequence&lt;SmartCardReaderStateOut&gt;&gt; getStatusChange(
              sequence&lt;SmartCardReaderStateIn&gt; readerStates,
              optional SmartCardGetStatusChangeOptions options = {});

          Promise&lt;SmartCardConnectResult&gt; connect(
              DOMString readerName,
              SmartCardAccessMode accessMode,
              optional SmartCardConnectOptions options = {});
        };
      </pre>
      <p>Instances of {{SmartCardContext}} are created with the internal slots
      described in the following table:</p>
      <table class="simple" data-dfn-for="SmartCardContext">
        <tr>
          <th>Internal slot
          <th>Initial value
          <th>Description (non-normative)
        </tr>
        <tr>
          <td><dfn>[[\resourceManager]]</dfn></td>
          <td>`null`</td>
          <td>The platform's [[PCSC5]] `RESOURCEMANAGER` to be used.</td>
        </tr>
        <tr>
          <td><dfn>[[\operationInProgress]]</dfn></td>
          <td>`false`</td>
          <td>Whether there is an ongoing PC/SC operation in this context.</td>
        </tr>
        <tr>
          <td><dfn>[[\connections]]</dfn></td>
          <td>An empty [=ordered set=]</td>
          <td>The existing {{SmartCardConnection}}s created by this context.</td>
        </tr>
        <tr>
          <td><dfn>[[\tracker]]</dfn></td>
          <td>`null`</td>
          <td>A [[PCSC5]] `SCARDTRACK` instance.</td>
        </tr>
        <tr>
          <td><dfn>[[\signal]]</dfn></td>
          <td>`null`</td>
          <td>The {{AbortSignal}} of the outstanding
            {{SmartCardContext/getStatusChange()}} call, if any.</td>
        </tr>
      </table>
      <section>
        <h3><dfn>listReaders()</dfn> method</h3>
        <p>The {{SmartCardContext/listReaders()}} method steps
        are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If [=this=].{{SmartCardContext/[[operationInProgress]]}} is
            `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
            {{DOMException}} and return |promise|.</li>
          <li>Set [=this=].{{SmartCardContext/[[operationInProgress]]}} to
            `true`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Let |resourceQuery:RESOURCEQUERY| be a new instance of the
                platform's [[PCSC5]] `RESOURCEQUERY` class, with
                [=this=].{{SmartCardContext/[[resourceManager]]}} as its
                constructor input parameter.</li>
              <! –– NB: Can't have "[]" in the data type part of a variable declaration. ––>
              <li>Let |groups:array of STR| be the platform's [[PCSC5]] `STR[]`
                containing the list of group names that is equivalent to "all
                readers in the system" in that platform.
                <aside class="note">This could be an empty `STR[]` in some
                  [[PCSC5]] implementations.</aside>
              </li>
              <li>Let |pcscReaders:array of STR| be an empty `STR[]`.
              <li>Invoke the `ListReaders` method of |resourceQuery| with
                |groups| as input and |pcscReaders| as output parameters.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>Destroy |resourceQuery|.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of [=this=].</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`:
                    <ol>
                      <li>If |responseCode| is `SCARD_E_NO_READERS_AVAILABLE`,
                      [=resolve=] |promise| with an empty `sequence` of
                      {{DOMString}}.
                        <aside class="note">
                          <p>`SCARD_E_NO_READERS_AVAILABLE` is not part of
                          [[PCSC5]] but it is still considered in this
                          specification as existing PC/SC implementations use
                          it.</p>
                        </aside>
                      </li>
                      <li>Otherwise, [=reject=] |promise| with an
                      [=exception=] {{SmartCardError/corresponding}} to
                      |responseCode|.</li>
                    </ol>
                  </li>
                  <li>Otherwise, [=resolve=] |promise| with a `sequence` of
                    {{DOMString}} equivalent to |pcscReaders|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
      </section>
      <section>
        <h3><dfn>getStatusChange()</dfn> method</h3>
        <p>The {{SmartCardContext/getStatusChange(readerStates, options)}} method steps
        are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If [=this=].{{SmartCardContext/[[operationInProgress]]}} is
            `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
            {{DOMException}} and return |promise|.</li>
          <li>If
            |options:SmartCardGetStatusChangeOptions|["{{SmartCardGetStatusChangeOptions/signal}}"]
            [=map/exists=], run the following steps:
            <ol>
              <li>Let |signal:AbortSignal| be
                |options|["{{SmartCardGetStatusChangeOptions/signal}}"].</li>
              <li>If |signal| is [=AbortSignal/aborted=], [=reject=] |promise|
                with |signal|'s [=AbortSignal/abort reason=] and return
                |promise|.</li>
              <li>Set [=this=].{{SmartCardContext/[[signal]]}} to |signal|</li>
              <li>[=AbortSignal/Add=] the {{SmartCardContext/Cancel the outstanding
                GetStatusChange}} algorithm to |signal|.</li>
            </ol>
          </li>
          <li>Let |pcscTimeout:DWORD| be a [[PCSC5]] `DWORD` set to [[PCSC5]]
            `INFINITE`.</li>
          <li>If
            |options|["{{SmartCardGetStatusChangeOptions/timeout}}"]
            [=map/exists=], set |pcscTimeout| to
            |options|["{{SmartCardGetStatusChangeOptions/timeout}}"].</li>
          <li>Let |pcscReaderStates:array of SCARD_READERSTATE| be a [[PCSC5]]
            `SCARD_READERSTATE[]` [=SmartCardReaderStateIn/corresponding=] to
            |readerStates:sequence&lt;SmartCardReaderStateIn&gt;|.</li>
          <li>Set [=this=].{{SmartCardContext/[[operationInProgress]]}} to
            `true`.</li>
          <li>Set [=this=].{{SmartCardContext/[[tracker]]}} to a new instance of the
            platform's [[PCSC5]] `SCARDTRACK` class, with
            [=this=].{{SmartCardContext/[[resourceManager]]}} as its
            constructor input parameter.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Call
                [=this=].{{SmartCardContext/[[tracker]]}}.`GetStatusChange()`
                with |pcscReaderStates| and |pcscTimeout| as input parameters.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                [[PCSC5]] `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>Set [=this=].{{SmartCardContext/[[tracker]]}} to `null`.</li>
                  <li>[=Clear the operationInProgress=] of [=this=].</li>
                  <li>Let |abortReason| be {{undefined}}.</li>
                  <li>If [=this=].{{SmartCardContext/[[signal]]}} is not `null`,
                    run the following steps:
                    <ol>
                      <li>If [=this=].{{SmartCardContext/[[signal]]}} is
                        [=AbortSignal/aborted=] then set |abortReason| to
                        [=this=].{{SmartCardContext/[[signal]]}}'s
                      [=AbortSignal/abort reason=].</li>
                      <li>[=AbortSignal/Remove=] the {{SmartCardContext/cancel the
                        outstanding GetStatusChange}} algorithm from
                        [=this=].{{SmartCardContext/[[signal]]}}.</li>
                      <li>Set [=this=].{{SmartCardContext/[[signal]]}} to
                        `null`.</li>
                    </ol>
                  </li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, run the
                    following steps:
                    <ol>
                      <li>If |responseCode| is `SCARD_E_CANCELLED` and
                        |abortReason| is not {{undefined}} then [=reject=]
                        |promise| with |abortReason|.</li>
                      <li>Otherwise, [=reject=] |promise| with an [=exception=]
                        {{SmartCardError/corresponding}} to |responseCode|.</li>
                      <li>Return.</li>
                    </ol>
                  </li>
                  <li>Let
                    |readerStatesOut:sequence&lt;SmartCardReaderStateOut&gt;| be
                    a sequence of {{SmartCardReaderStateOut}}
                    [=SmartCardReaderStateOut/corresponding=] to
                    |pcscReaderStates|.</li>
                  <li>[=Resolve=] |promise| with |readerStatesOut|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>

        <section data-dfn-for="SmartCardReaderStateIn">
          <h4><dfn>SmartCardReaderStateIn</dfn> dictionary</h4>
          <pre class="idl">
            dictionary SmartCardReaderStateIn {
              required DOMString readerName;
              required SmartCardReaderStateFlagsIn currentState;
              unsigned long currentCount;
            };
          </pre>

          <dl>
            <dt><dfn>readerName</dfn> member</dt>
            <dd>Name of the smart card reader.</dd>

            <dt><dfn>currentState</dfn> member</dt>
            <dd>The current state of that smart card reader as known by the
              application.</dd>

            <dt><dfn>currentCount</dfn> member</dt>
            <dd>The current number of card insertion and removal events in this
              reader, as known by the application.</dd>
          </dl>
          <p>Given a sequence of {{SmartCardReaderStateIn}} named
          |readerStates:sequence&lt;SmartCardReaderStateIn&gt;|, a
          <dfn data-dfn-for="SmartCardReaderStateIn">corresponding</dfn>
          [[PCSC5]] `SCARD_READERSTATE[]` is created with the following
          steps:</p>
          <ol>
            <li>Let |pcscReaderStates:array of SCARD_READERSTATE| be an empty
              `SCARD_READERSTATE[]`.</li>
            <li>[=list/For each=] |stateIn:SmartCardReaderStateIn| in |readerStates|:
              <ol>
                <li>Let |pcscState:SCARD_READERSTATE| be a `SCARD_READERSTATE`.</li>
                <li>Set |pcscState|.`Reader` to
                  |stateIn|["{{SmartCardReaderStateIn/readerName}}"].</li>
                <li>Set |pcscState|.`CurrentState` to the `DWORD`
                  [=SmartCardReaderStateFlagsIn/corresponding=]
                to |stateIn|["{{SmartCardReaderStateIn/currentState}}"].</li>
                <li>If |stateIn|["{{SmartCardReaderStateIn/currentCount}}"]
                  [=map/exists=], [=SmartCardContext/set the high word=] of
                  |pcscState|.`CurrentState` to
                  |stateIn|["{{SmartCardReaderStateIn/currentCount}}"].</li>
                <li>Set |pcscState|.`EventState` to zero.</li>
                <li>[=list/Append=] |pcscState| to |pcscReaderStates|.</li>
              </ol>
            </li>
            <li>Return |pcscReaderStates|.</li>
          </ol>

          <section data-dfn-for="SmartCardReaderStateFlagsIn">
            <h5><dfn>SmartCardReaderStateFlagsIn</dfn> dictionary</h4>

            <pre class="idl">
              dictionary SmartCardReaderStateFlagsIn {
                boolean unaware = false;
                boolean ignore = false;
                boolean unavailable = false;
                boolean empty = false;
                boolean present = false;
                boolean exclusive = false;
                boolean inuse = false;
                boolean mute = false;
                boolean unpowered = false;
              };
            </pre>

            <dl>
              <dt><dfn>unaware</dfn> member</dt>
              <dd>The application is unaware of the current state, and would like
                to know.</dd>

              <dt><dfn>ignore</dfn> member</dt>
              <dd>The application is not interested in this reader, and it should
                not be considered during monitoring operations.</dd>

              <dt><dfn>unavailable</dfn> member</dt>
              <dd>The application believes that this reader is not available for
                use.</dd>

              <dt><dfn>empty</dfn> member</dt>
              <dd>The application believes that there is not a card in the
                reader.</dd>

              <dt><dfn>present</dfn> member</dt>
              <dd>The application believes that there is a card in the
                reader.</dd>

              <dt><dfn>exclusive</dfn> member</dt>
              <dd>The application believes that the card in the reader is
                allocated for exclusive use by another application.</dd>

              <dt><dfn>inuse</dfn> member</dt>
              <dd>The application believes that the card in the reader is in use
                by one or more other applications, but may be connected to in
                shared mode. </dd>

              <dt><dfn>mute</dfn> member</dt>
              <dd>The application believes that there is an unresponsive card in
                the reader.</dd>

              <dt><dfn>unpowered</dfn> member</dt>
              <dd>The application believes that the card in the reader has not
                been powered up.</dd>
            </dl>

            <p>The [[PCSC5]] `DWORD`
              <dfn data-dfn-for=SmartCardReaderStateFlagsIn>corresponding</dfn>
              to a given {{SmartCardReaderStateFlagsIn}} is created with the
              following steps:</p>
            <ol>
              <li>Let |flagsIn:SmartCardReaderStateFlagsIn| be the given
                {{SmartCardReaderStateFlagsIn}}.</li>
              <li>Let |pcscFlags:DWORD| be a `DWORD` set to zero.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/unaware}}"] is
                `true`, [=add a flag|add=] [[PCSC5]] `SCARD_STATE_UNAWARE` to
                |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/ignore}}"] is
                `true`, [=add a flag|add=] [[PCSC5]] `SCARD_STATE_IGNORE` to
                |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/unavailable}}"]
                is `true`, [=add a flag|add=] [[PCSC5]]
                `SCARD_STATE_UNAVAILABLE` to |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/empty}}"] is
                `true`, [=add a flag|add=] [[PCSC5]] `SCARD_STATE_EMPTY` to
                |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/present}}"] is
                `true`, [=add a flag|add=] [[PCSC5]] `SCARD_STATE_PRESENT` to
                |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/exclusive}}"] is
                `true`, [=add a flag|add=] [[PCSC5]] `SCARD_STATE_EXCLUSIVE` to
                |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/inuse}}"] is
                `true`, [=add a flag|add=] [[PCSC5]] `SCARD_STATE_INUSE` to
                |pcscFlags|.</li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/mute}}"] is
                `true`, [=add a flag|add=] `SCARD_STATE_MUTE` to
                |pcscFlags|.
              </li>
              <li>If |flagsIn|["{{SmartCardReaderStateFlagsIn/unpowered}}"] is
                `true`, [=add a flag|add=] `SCARD_STATE_UNPOWERED` to
                |pcscFlags|.</li>
              <li>Return |pcscFlags|.</li>
            </ol>
            <aside class="note">
              <p>`SCARD_STATE_MUTE` and `SCARD_STATE_UNPOWERED` are not part of
              [[PCSC5]] but are still considered in this specification as
              existing PC/SC implementations use it.</p>
            </aside>
          </section>
        </section>
        <section data-dfn-for="SmartCardReaderStateOut">
          <h4><dfn>SmartCardReaderStateOut</dfn> dictionary</h4>
          <p>The actual state of a smart card reader.</p>

          <pre class="idl">
            dictionary SmartCardReaderStateOut {
              required DOMString readerName;
              required SmartCardReaderStateFlagsOut eventState;
              required unsigned long eventCount;
              ArrayBuffer answerToReset;
            };
          </pre>

          <dl>
            <dt><dfn>readerName</dfn> member</dt>
            <dd>Name of the smart card reader.</dd>

            <dt><dfn>eventState</dfn> member</dt>
            <dd>The actual state of that smart card reader.</dd>

            <dt><dfn>eventCount</dfn> member</dt>
            <dd>The actual number of card insertion and removal events in this
              reader.</dd>

            <dt><dfn>answerToReset</dfn> member</dt>
            <dd>The inserted card's [[ISO7186-3]] Answer To Reset (ATR), if
              applicable.</dd>
          </dl>

          <p>Given a [[PCSC5]] `SCARD_READERSTATE[]` named
          |pcscReaderStates:array of SCARD_READERSTATE|, a <dfn
          data-dfn-for="SmartCardReaderStateOut">corresponding</dfn> sequence of
          {{SmartCardReaderStateOut}} is created with the following steps:</p>
          <ol>
            <li>Let |readerStatesOut:sequence&lt;SmartCardReaderStateOut&gt;| be
              an empty sequence of {{SmartCardReaderStateOut}}.</li>
            <li>[=list/For each=] |pcscState:SCARD_READERSTATE| in
              |pcscReaderStates|:
              <ol>
                <li>Let |stateOut:SmartCardReaderStateOut| be a
                  {{SmartCardReaderStateOut}}.</li>
                <li>Set |stateOut|["{{SmartCardReaderStateOut/readerName}}"] to
                  |pcscState|.`Reader`.</li>
                <li>Set |stateOut|["{{SmartCardReaderStateOut/eventState}}"] to
                  the {{SmartCardReaderStateFlagsOut}} dictionary
                  [=SmartCardReaderStateFlagsOut/corresponding=]
                  to |pcscState|.`EventState`.</li>
                <li>Set |stateOut|["{{SmartCardReaderStateOut/eventCount}}"] to
                  the [=SmartCardContext/high word=] of |pcscState|.`EventState`.
                  <aside class="note" title="Number of card insertion and removal
                    events">
                    <p>Having the number of card insertion and removal events
                    stored in the upper 2 bytes of the `EventState` and
                    `CurrentState` `DWORD`s is not part of [[PCSC5]] but it is
                    still considered in this specification as several existing
                    PC/SC implementations use it.</p>
                    <p>In PC/SC implementations where this information is not
                    available, the upper two bytes of `EventState` will always
                    be zero and so the resulting
                    "{{SmartCardReaderStateOut/eventCount}}" will be zero.</p>
                    <p>The algorithms in this specification assume that PC/SC
                    implementations will define all [[PCSC5]] `SCARD_STATE_*`
                    flags to be `DWORD` values no higher than `0xFFFF`.</p>
                  </aside>
                </li>
                <li>If the platform's `SCARD_READERSTATE` structure has a member
                  containing the card's [[ISO7186-3]] Answer To Reset, set
                  |stateOut|["{{SmartCardReaderStateOut/answerToReset}}"] to
                  that value.</li>
                <li>[=list/Append=] |stateOut| to |readerStatesOut|.</li>
              </ol>
            </li>
            <li>Return |readerStatesOut|.</li>
          </ol>

          <section data-dfn-for="SmartCardReaderStateFlagsOut">
            <h5><dfn>SmartCardReaderStateFlagsOut</dfn> dictionary</h4>

            <pre class="idl">
              dictionary SmartCardReaderStateFlagsOut {
                boolean ignore = false;
                boolean changed = false;
                boolean unavailable = false;
                boolean unknown = false;
                boolean empty = false;
                boolean present = false;
                boolean exclusive = false;
                boolean inuse = false;
                boolean mute = false;
                boolean unpowered = false;
              };
            </pre>

            <dl>
              <dt><dfn>ignore</dfn> member</dt>
              <dd>The application requested that this reader be ignored.</dd>

              <dt><dfn>changed</dfn> member</dt>
              <dd>There is a difference between the state input by the calling
                application, and the actual state.</dd>

              <dt><dfn>unavailable</dfn> member</dt>
              <dd>This reader is not available for use.</dd>

              <dt><dfn>unknown</dfn> member</dt>
              <dd>The reader name given by the application is not known.</dd>

              <dt><dfn>empty</dfn> member</dt>
              <dd>There is no card in the reader.</dd>

              <dt><dfn>present</dfn> member</dt>
              <dd>There is a card in the reader.</dd>

              <dt><dfn>exclusive</dfn> member</dt>
              <dd>The card in the reader is allocated for exclusive use by
                another application.</dd>

              <dt><dfn>inuse</dfn> member</dt>
              <dd>The card in the reader is in use by one or more other
                applications, but may be connected to in shared mode. </dd>

              <dt><dfn>mute</dfn> member</dt>
              <dd>There is an unresponsive card in the reader.</dd>

              <dt><dfn>unpowered</dfn> member</dt>
              <dd>The card in the reader has not been powered up.</dd>
            </dl>

            <p>Given a [[PCSC5]] `DWORD` named |pcscFlags:DWORD|, a <dfn
              data-dfn-for="SmartCardReaderStateFlagsOut">corresponding</dfn>
              {{SmartCardReaderStateFlagsOut}} dictionary is created with the
              following steps:</p>
            <ol>
              <li>Let |flagsOut:SmartCardReaderStateFlagsOut| be a
                {{SmartCardReaderStateFlagsOut}} dictionary with [=dictionary
                member/default value|default members=].</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_IGNORE`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/ignore}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_CHANGED`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/changed}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_UNAVAILABLE`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/unavailable}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_UNKNOWN`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/unknown}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_EMPTY`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/empty}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_PRESENT`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/present}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_EXCLUSIVE`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/exclusive}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] [[PCSC5]]
                `SCARD_STATE_INUSE`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/inuse}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] `SCARD_STATE_MUTE`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/mute}}"] to
                `true`.</li>
              <li>If |pcscFlags| [=has a flag|has=] `SCARD_STATE_UNPOWERED`, set
                |flagsOut|["{{SmartCardReaderStateFlagsOut/unpowered}}"] to
                `true`.</li>
              <li>Return |flagsOut|.</li>
            </ol>
            <aside class="note">
              <p>`SCARD_STATE_MUTE` and `SCARD_STATE_UNPOWERED` are not part of
              [[PCSC5]] but are still considered in this specification as
              existing PC/SC implementations use it.</p>
            </aside>
          </section>
        </section>
        <section data-dfn-for="SmartCardGetStatusChangeOptions">
          <h4><dfn>SmartCardGetStatusChangeOptions</dfn> dictionary</h4>
          <pre class="idl">
            dictionary SmartCardGetStatusChangeOptions {
              DOMHighResTimeStamp timeout;
              AbortSignal signal;
            };
          </pre>

          <dl>
            <dt><dfn>timeout</dfn> member</dt>
            <dd>Timeout parameter for the GetStatusChange() [[PCSC5]] method. If
            not specified, a timeout value of INFINITE (which is defined system
            dependent) will be used.</dd>

            <dt><dfn>signal</dfn> member</dt>
            <dd>When triggered, the platform's [[PCSC5]] Cancel() method is
            called.</dd>
          </dl>
        </section>
      </section>
      <section>
        <h3><dfn>connect()</dfn> method</h3>
        <p>The {{SmartCardContext/connect(readerName, accessMode, options)}}
        method steps are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If [=this=].{{SmartCardContext/[[operationInProgress]]}} is
            `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
            {{DOMException}} and return |promise|.</li>
          <li>Set [=this=].{{SmartCardContext/[[operationInProgress]]}} to
            `true`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Let |accessFlags:DWORD| be a [[PCSC5]] `DWORD`
              [=SmartCardAccessMode/corresponding=] to
              |accessMode:SmartCardAccessMode|.</li>
              <li>Let |protocolFlags:DWORD| be a `DWORD` set to `0`.</li>
              <li>If
              |options:SmartCardConnectOptions|["{{SmartCardConnectOptions/preferredProtocols}}"]
              [=map/exists=], set |protocolFlags| to its
              [=SmartCardProtocol/corresponding flags=].</li>
              <li>Let |activeProtocol:DWORD| be a `DWORD` set to `0`.</li>
              <li>Let |comm:SCARDCOMM| be a new instance of the platform's
              [[PCSC5]] `SCARDCOMM` class, with
              [=this=].{{SmartCardContext/[[resourceManager]]}} as its
              constructor parameter.</li>
              <li>Call |comm|.`Connect()` with |readerName|, |accessFlags|
              and |protocolFlags| as input and |activeProtocol| as output parameters.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of [=this=].</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`:
                    <ol>
                      <li>Destroy |comm|.</li>
                      <li>[=Reject=] |promise| with an [=exception=]
                      {{SmartCardError/corresponding}} to |responseCode| and abort these steps.</li>
                    </ol>
                  </li>
                  <li>Let |result:SmartCardConnectResult| be an empty
                  {{SmartCardConnectResult}} dictionary.</li>
                  <li>Let |connection:SmartCardConnection| be a new
                  {{SmartCardConnection}}.</li>
                  <li>[=set/Append=] |connection| to
                    [=this=].{{SmartCardContext/[[connections]]}}.</li>
                  <li>Set |connection|.{{SmartCardConnection/[[comm]]}} to |comm|.
                  <li>Set |connection|.{{SmartCardConnection/[[context]]}} to
                    [=this=].
                  <li>Set |connection|.{{SmartCardConnection/[[activeProtocol]]}} to
                    |activeProtocol|.
                  <li>Set |result|["{{SmartCardConnectResult/connection}}"] to
                  |connection|.</li>
                  <li>If |activeProtocol| is a [=SmartCardProtocol/valid
                  protocol value=], set
                  |result|["{{SmartCardConnectResult/activeProtocol}}"] to the
                  corresponding {{SmartCardProtocol}}.</li>
                  <li>[=Resolve=] |promise| with |result|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
        <section data-dfn-for="SmartCardProtocol">
          <h4><dfn>SmartCardProtocol</dfn> enum</h4>
          <pre class="idl">
            enum SmartCardProtocol {
              "raw",
              "t0",
              "t1"
            };
          </pre>
          <dl>
            <dt><dfn>raw</dfn></dt>
            <dd>"Raw" mode. May be used to support arbitrary data exchange
            protocols for special-purpose requirements. Corresponds to a
            [[PCSC5]] `SCARD_PROTOCOL_RAW` `DWORD`.</dd>

            <dt><dfn>t0</dfn></dt>
            <dd>[[ISO7186-3]] T=0. Asynchronous half duplex character
            transmission protocol. Corresponds to a [[PCSC5]]
            `SCARD_PROTOCOL_T0` `DWORD`.</dd>

            <dt><dfn>t1</dfn></dt>
            <dd>[[ISO7186-3]] T=1. Asynchronous half duplex block transmission
            protocol. Corresponds to a [[PCSC5]] `SCARD_PROTOCOL_T1`
            `DWORD`.</dd>
          </dl>
          <p>A [[PCSC5]] `DWORD` is a <dfn data-dfn-for="SmartCardProtocol">valid protocol value</dfn> if it is either
          [[PCSC5]] `SCARD_PROTOCOL_T0`, [[PCSC5]] `SCARD_PROTOCOL_T1` or
          [[PCSC5]] `SCARD_PROTOCOL_RAW`.</p>
          <p>Given a sequence of {{SmartCardProtocol}} named
          |protocols:sequence&lt;SmartCardProtocol&gt;|, a [[PCSC5]] `DWORD`
          with the <dfn data-dfn-for="SmartCardProtocol">corresponding
          flags</dfn> is created with the following steps:</p>
          <ol>
            <li>Let |flags:DWORD| be a `DWORD` set to `0`.</li>
            <li>[=list/For each=] |protocol:SmartCardProtocol| in |protocols|,
              [=add a flag|add=] the corresponding `DWORD` of |protocol| to |flags|.
            </li>
            <li>Return |flags|.</li>
          </ol>
        </section>
        <section data-dfn-for="SmartCardConnectResult">
          <h4><dfn>SmartCardConnectResult</dfn> dictionary</h4>
          <pre class="idl">
            dictionary SmartCardConnectResult {
              required SmartCardConnection connection;
              SmartCardProtocol activeProtocol;
            };
          </pre>
          <dl>
            <dt><dfn>connection</dfn> member</dt>
            <dd>An interface to the connection created.</dd>

            <dt><dfn>activeProtocol</dfn> member</dt>
            <dd>The protocol actually in use.</dd>
          </dl>
        </section>
        <section data-dfn-for="SmartCardAccessMode">
          <h4><dfn>SmartCardAccessMode</dfn> enum</h5>
          <pre class="idl">
            enum SmartCardAccessMode {
              "shared",
              "exclusive",
              "direct"
            };
          </pre>
          <dl>
            <dt><dfn>shared</dfn></dt>
            <dd>Application is willing to share access to card with other
              applications.</dd>
            <dt><dfn>exclusive</dfn></dt>
            <dd>Application requires exclusive access to the card.</dd>
            <dt><dfn>direct</dfn></dt>
            <dd>Application requires connection to reader whether or not card
              is present. Implies exclusive access.</dd>
          </dl>
          <p>Given a {{SmartCardAccessMode}} enum named
          |accessMode:SmartCardAccessMode|, a <dfn
          data-dfn-for="SmartCardAccessMode">corresponding</dfn> [[PCSC5]]
          `DWORD` is created with the following steps:</p>
          <ol>
            <li>Let |dword:DWORD| be a `DWORD` set to `0`.
            <li>If |accessMode| is "{{SmartCardAccessMode/shared}}", set |dword| to [[PCSC5]]
            `SCARD_SHARE_SHARED`.</li>
            <li>If |accessMode| is "{{SmartCardAccessMode/exclusive}}", set |dword| to [[PCSC5]]
            `SCARD_SHARE_EXCLUSIVE`.</li>
            <li>If |accessMode| is "{{SmartCardAccessMode/direct}}", set |dword| to [[PCSC5]]
            `SCARD_SHARE_DIRECT`.</li>
            <li>Return |dword|.</li>
          </ol>
        </section>
        <section data-dfn-for="SmartCardConnectOptions">
          <h4><dfn>SmartCardConnectOptions</dfn> dictionary</h5>
          <pre class="idl">
            dictionary SmartCardConnectOptions {
              sequence&lt;SmartCardProtocol&gt; preferredProtocols;
            };
          </pre>
          <dl>
            <dt><dfn>preferredProtocols</dfn></dt>
            <dd>Card communication protocols that may be used.</dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>Auxiliary algorithms and definitions</h4>

        <p>To <dfn>clear the operationInProgress</dfn> of a
        {{SmartCardContext}} |context:SmartCardContext|, perform the following steps:</p>
        <ol>
          <li>[=Assert=]: |context|.{{SmartCardContext/[[operationInProgress]]}}
            is `true`.</li>
          <li>Set |context|.{{SmartCardContext/[[operationInProgress]]}} to
            `false`.</li>
          <li>[=set/For each=] |connection:SmartCardConnection| of
            |context|.{{SmartCardContext/[[connections]]}}:
            <ol>
              <li>[=SmartCardConnection/End any settled transaction=] of
                |connection|.</li>
              <li>If |context|.{{SmartCardContext/[[operationInProgress]]}} is
                `true`, abort there steps.</li>
            </ol>
          </li>
        </ol>
        <aside class="note">
          <p>A transaction ends when the {{Promise}} returned by the
          {{SmartCardTransactionCallback}} passed to
          {{SmartCardConnection/startTransaction()}} settles. At this
          point the user agent should call [[PCSC5]] `EndTransaction()` to
          effect that on the platform's PC/SC stack. But that won't be
          possible if at that moment there's already another PC/SC
          operation taking place in the connection's PC/SC context. The
          user agent then has to wait until this ongoing PC/SC operation
          finishes before ending that settled transaction.</p>
        </aside>

        <p>The <dfn>cancel the outstanding GetStatusChange</dfn>
        algorithm steps are:</p>
        <ol>
          <li>Call [=this=].{{SmartCardContext/[[tracker]]}}.`Cancel()`.</li>
        </ol>

        <p>The <dfn>high word</dfn> of a [[PCSC5]] `DWORD` is the result of an
        unsigned right shift of 16 bits on that `DWORD`.</p>

        <p>To <dfn>set the high word</dfn> of a [[PCSC5]] `DWORD` named
        |dword:DWORD| to a given number |n|, perform the following steps.</p>
        <ol>
          <li>Set |dword| to |dword| bitwise AND `0xFFFF`.</li>
          <li>Let |shiftedN| be the result of a left shift of 16 bits on |n|.</li>
          <li>Set |dword| to |dword| bitwise OR |shiftedN|.</li>
        </ol>

        <p>To <dfn>add a flag</dfn> |f:DWORD| to a [[PCSC5]] `DWORD`
        |flags:DWORD|, set |flags| to |flags| bitwise OR |f|.</p>

        <p>A [[PCSC5]] `DWORD` |flags:DWORD| <dfn>has a flag</dfn> |f:DWORD|
        if |flags| bitwise AND |f| is |f|.</p>
      </section>
    </section>

    <section data-dfn-for="SmartCardConnection">
      <h2><dfn>SmartCardConnection</dfn> interface</h2>
      <pre class="idl">
        [Exposed=(DedicatedWorker, SharedWorker, Window), SecureContext]
        interface SmartCardConnection {
          Promise&lt;undefined&gt; disconnect(optional SmartCardDisposition disposition = "leave");

          Promise&lt;ArrayBuffer&gt; transmit(BufferSource sendBuffer,
              optional SmartCardTransmitOptions options = {});

          Promise&lt;undefined&gt; startTransaction(SmartCardTransactionCallback transaction,
              optional SmartCardTransactionOptions options = {});

          Promise&lt;SmartCardConnectionStatus&gt; status();

          Promise&lt;ArrayBuffer&gt; control([EnforceRange] unsigned long controlCode,
              BufferSource data);

          Promise&lt;ArrayBuffer&gt; getAttribute([EnforceRange] unsigned long tag);
          Promise&lt;undefined&gt; setAttribute([EnforceRange] unsigned long tag, BufferSource value);
        };

        callback SmartCardTransactionCallback = Promise&lt;SmartCardDisposition?&gt; ();
      </pre>
      <p>Instances of {{SmartCardConnection}} are created with the internal slots
      described in the following table:</p>
      <table class="simple" data-dfn-for="SmartCardConnection">
        <tr>
          <th>Internal slot
          <th>Initial value
          <th>Description (non-normative)
        </tr>
        <tr>
          <td><dfn>[[\comm]]</dfn></td>
          <td>`null`</td>
          <td>The platform's [[PCSC5]] `SCARDCOMM` to be used.</td>
        </tr>
        <tr>
          <td><dfn>[[\context]]</dfn></td>
          <td>`null`</td>
          <td>The {{SmartCardContext}} that created this instance.</td>
        </tr>
        <tr>
          <td><dfn>[[\activeProtocol]]</dfn></td>
          <td>0</td>
          <td>The active protocol `DWORD`, as returned by the platform's
            [[PCSC5]] implementation.</td>
        </tr>
        <tr>
          <td><dfn>[[\transactionState]]</dfn></td>
          <td>`null`</td>
          <td>Holds the [=transaction state|state=] of an ongoing transaction
            started with {{SmartCardConnection/startTransaction()}}, if
            any.</td>
        </tr>
      </table>
        <aside class="note" title="Lack of the reconnect method">
          <p>[[PCSC5]] mentions also the `Reconnect` method, which has no equivalent here.
            This is because its behavior differs between implementations&mdash;PC/SC Lite does
            not release the transactions held by the process, while Microsoft's WinSCard
            does. While PCSC lite behavior cannot be replicated cross-platform, Microsoft
            Windows WinSCard can be achieved via calling `Disconnect` + `Connect`. Moreover,
            in case of Javascript API the benefit of maintaining the same connection handle
            ID is lost, as the ID is not exposed, only the `SmartCardConnection` which is an
            abstraction over it. Hence, there are no material benefits to including this method in
            the web API.</p>
        </aside>
      <section>
        <h3><dfn>disconnect()</dfn> method</h3>
        <p>The {{SmartCardConnection/disconnect(disposition)}} method steps
        are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Call [=this=].{{SmartCardConnection/[[comm]]}}.`Disconnect()`
                with a `DWORD` corresponding to
                |disposition:SmartCardDisposition| as input parameter.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of
                    [=this=].{{SmartCardConnection/[[context]]}}.</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, [=reject=]
                    |promise| with an [=exception=]
                    {{SmartCardError/corresponding}} to |responseCode| and abort
                    these steps.</li>
                  <li>Destroy [=this=].{{SmartCardConnection/[[comm]]}}.</li>
                  <li>Set [=this=].{{SmartCardConnection/[[comm]]}} to `null`.</li>
                  <li>[=Resolve=] |promise|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>

        <section data-dfn-for="SmartCardDisposition">
          <h4><dfn>SmartCardDisposition</dfn> enum</h3>
          <pre class="idl">
            enum SmartCardDisposition {
              "leave",
              "reset",
              "unpower",
              "eject"
            };
          </pre>
          <dl>
            <dt><dfn>leave</dfn></dt>
            <dd>Don't alter card state. Corresponds to a [[PCSC5]]
              `SCARD_LEAVE_CARD` `DWORD`.</dd>
            <dt><dfn>reset</dfn></dt>
            <dd>Reset the card. Corresponds to a [[PCSC5]] `SCARD_RESET_CARD`
              `DWORD`.</dd>
            <dt><dfn>unpower</dfn></dt>
            <dd>Unpower and terminate access to the card. Corresponds to a
              [[PCSC5]] `SCARD_UNPOWER_CARD` `DWORD`.</dd>
            <dt><dfn>eject</dfn></dt>
            <dd>Eject the card from the reader. Corresponds to a [[PCSC5]]
              `SCARD_EJECT_CARD` `DWORD`.</dd>
          </dl>
        </section>
      </section>
      <section>
        <h3><dfn>transmit()</dfn> method</h3>
        <p>The {{SmartCardConnection/transmit(sendBuffer, options)}} method steps
        are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>Let |protocol:DWORD| be a [[PCSC5]] `DWORD` set to
            [=this=].{{SmartCardConnection/[[activeProtocol]]}}.
          <li>If
            |options:SmartCardTransmitOptions|["{{SmartCardTransmitOptions/protocol}}"]
            [=map/exists=], set |protocol| to the `DWORD` corresponding to
            |options:SmartCardTransmitOptions|["{{SmartCardTransmitOptions/protocol}}"].
          <li>If |protocol| is not a [=SmartCardProtocol/valid protocol value=],
            [=reject=] |promise| with a "{{InvalidStateError}}" {{DOMException}}
            and return |promise|.</li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Let |sendPci:SCARD_IO_HEADER| be the platform's [[PCSC5]]
            `SCARD_IO_HEADER` corresponding to
            [=this=].{{SmartCardConnection/[[activeProtocol]]}}.</li>
          <li>Let |pcscSendBuffer:array of BYTE| be a [[PCSC5]] `BYTE[]`
            containing |sendBuffer:BufferSource|.</li>
          <li>Let |recvPci:SCARD_IO_HEADER| be the platform's `SCARD_IO_HEADER`
            equivalent of empty or null.</li>
          <li>Let |recvBuffer:array of BYTE| be a `BYTE[]` big enough to hold
            the largest [[ISO7186-3]] extended response APDU (65538 bytes).</li>
          <li>Let |recvLength:DWORD| be a `DWORD` set to `0`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Call [=this=].{{SmartCardConnection/[[comm]]}}.`Transmit()`
                with |sendPci|, |pcscSendBuffer|, |recvPci|, |recvBuffer| and
                |recvLength| as arguments.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of
                    [=this=].{{SmartCardConnection/[[context]]}}.</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, [=reject=]
                    |promise| with an [=exception=]
                    {{SmartCardError/corresponding}} to |responseCode| and abort
                    these steps.</li>
                  <li>[=Resolve=] |promise| with an {{ArrayBuffer}} containing
                    the first |recvLength| bytes of |recvBuffer|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
        <section data-dfn-for="SmartCardTransmitOptions">
          <h4><dfn>SmartCardTransmitOptions</dfn> dictionary</h3>
          <pre class="idl">
            dictionary SmartCardTransmitOptions {
              SmartCardProtocol protocol;
            };
          </pre>
          <dl>
            <dt><dfn>protocol</dfn> member</dt>
            <dd>The protocol to be used in the transmission.</dd>
          </dl>
        </section>
      </section>
      <section>
        <h3><dfn>startTransaction()</dfn> method</h3>
        <p>The {{SmartCardConnection/startTransaction(transaction, options)}}
        method steps are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[transactionState]]}} is not
            `null`,  [=reject=] |promise| with a "{{InvalidStateError}}"
            {{DOMException}} and return |promise|.</li>
          <li>Let |signal| be an {{AbortSignal}} set to `null`.</li>
          <li>If
            |options:SmartCardTransactionOptions|["{{SmartCardTransactionOptions/signal}}"]
            [=map/exists=], run the following steps:
            <ol>
              <li>If
                |options:SmartCardTransactionOptions|["{{SmartCardTransactionOptions/signal}}"]
                is [=AbortSignal/aborted=], [=reject=] |promise| with
                |options:SmartCardTransactionOptions|["{{SmartCardTransactionOptions/signal}}"]'s
                [=AbortSignal/abort reason=] and return |promise|.</li>
              <li>Set |signal| to
                |options|["{{SmartCardTransactionOptions/signal}}"].</li>
              <li>[=AbortSignal/Add=] the {{SmartCardConnection/cancel}}
                algorithm to |signal|.</li>
            </ol>
          </li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Call
                [=this=].{{SmartCardConnection/[[comm]]}}.`BeginTransaction()`.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned [[PCSC5]]
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] to
                [=process the result of a BeginTransaction=] with [=this=],
                |responseCode|, |signal|, |transaction| and |promise|.
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
        <section data-dfn-for="SmartCardTransactionOptions">
          <h4><dfn>SmartCardTransactionOptions</dfn> dictionary</h4>
          <pre class="idl">
            dictionary SmartCardTransactionOptions {
              AbortSignal signal;
            };
          </pre>

          <dl>
            <dt><dfn>signal</dfn> member</dt>
            <dd>When triggered, the platform's [[PCSC5]] Cancel() method is
            called.</dd>
          </dl>
        </section>
        <section>
          <h4>Auxiliary algorithms and definitions</h4>
          <p>A <dfn>transaction state</dfn> is a [=struct=] with the following
          [=struct/items=]:</p>
          <table class="simple" data-dfn-for="transaction state">
            <tr>
              <th>Item
              <th>Description (non-normative)
            </tr>
              <td><dfn>pendingDisposition</dfn></td>
              <td>If set, it means once the ongoing PC/SC operation finishes
                [[PCSC5]] `EndTransaction()` should be called with this value as the
                {{SmartCardDisposition}} parameter.</td>
            </tr>
            <tr>
              <td><dfn>pendingException</dfn></td>
              <td>The exception to be used when rejecting
                [=transaction state/promise=].</td>
            </tr>
            <tr>
              <td><dfn>promise</dfn></td>
              <td>The pending {{Promise}} returned by a
                {{SmartCardConnection/startTransaction()}} call.</td>
            </tr>
          </table>
          <p>To <dfn>process the result of a BeginTransaction</dfn> given a
          {{SmartCardConnection}} |connection:SmartCardConnection|, a [[PCSC5]]
          `RESPONSECODE` |responseCode:RESPONSECODE|, an {{AbortSignal}}
          |signal:AbortSignal|, a {{SmartCardTransactionCallback}}
          |transaction:SmartCardTransactionCallback| and a {{Promise}}
          |promise:Promise|, perform the following steps:</p>
          <ol>
            <li>[=Clear the operationInProgress=] of
              |connection|.{{SmartCardConnection/[[context]]}}.</li>
            <li>Let |abortReason| be {{undefined}}.</li>
            <li>If |signal| is not `null`:
              <ol>
                <li>[=AbortSignal/Remove=] the
                  {{SmartCardConnection/cancel}} algorithm from
                  |signal|.</li>
                <li>If |signal| is [=AbortSignal/aborted=] then set
                  |abortReason| to |signal|'s [=AbortSignal/abort
                  reason=].</li>
              </ol>
            </li>
            <li>If |responseCode| is not `SCARD_S_SUCCESS`:
              <ol>
                <li>If |responseCode| is `SCARD_E_CANCELLED` and
                  |abortReason| is not {{undefined}} then [=reject=]
                  |promise| with |abortReason|.</li>
                <li>Otherwise, [=reject=] |promise| with an
                  [=exception=] {{SmartCardError/corresponding}} to
                  |responseCode|.</li>
                <li>Return.</li>
              </ol>
            </li>
            <li>Let |transactionState:transaction state| be a new [=transaction
              state=] with its [=transaction state/promise=] item set to
              |promise|.</li>
            <li>Set |connection|.{{SmartCardConnection/[[transactionState]]}}
              to |transactionState|.</li>
            <li>Let |callbackPromise:Promise| be the result of [=invoking=]
              |transaction|.</li>
            <li>[=promise/React=] to |callbackPromise|:
              <ul>
                <li>If |callbackPromise| was fulfilled with value |v|
                  then:
                  <ol>
                    <li>Let |disposition:SmartCardDisposition| be
                      "{{SmartCardDisposition/reset}}".
                    <li>If |v| is not {{undefined}}, set |disposition| to
                      |v|.</li>
                    <li>If
                      |connection|.{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
                      is `true`:
                      <ol>
                        <li>Set |transactionState|'s [=transaction
                          state/pendingException=] to a "{{InvalidStateError}}"
                          {{DOMException}}.</li>
                        <li>Set
                          |transactionState|'s [=transaction state/pendingDisposition=]
                          to |disposition|.</li>
                      </ol>
                    </li>
                    <li>Otherwise, [=end the transaction=] of |connection| with
                      |disposition|.</li>
                  </ol>
                </li>
                <li>If |callbackPromise| was rejected with reason |r|, then:
                  <ol>
                    <li>Set |transactionState|'s [=transaction
                      state/pendingException=] to |r|.</li>
                    <li>If
                      |connection|.{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
                      is `true`, set
                      |transactionState|'s [=transaction state/pendingDisposition=] to
                      "{{SmartCardDisposition/reset}}".</li>
                    <li>Otherwise, [=end the transaction=] of |connection| with
                      "{{SmartCardDisposition/reset}}".</li>
                  </ol>
                </li>
              </ul>
            </li>
          </ol>

          <p>To <dfn>end the transaction</dfn> of a {{SmartCardConnection}}
          |connection:SmartCardConnection| with a {{SmartCardDisposition}}
          |disposition:SmartCardDisposition|, perform the following steps:</p>
          <ol>
            <li>[=Assert=]:
              |connection|.{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
              is `false`.</li>
            <li>[=Assert=]:
              |connection|.{{SmartCardConnection/[[transactionState]]}} is not
              `null`.</li>
            <li>[=Assert=]: |connection|.{{SmartCardConnection/[[transactionState]]}}'s
              [=transaction state/pendingDisposition=] is `null`.</li>
            <li>Let |transactionPromise:Promise| be
              |connection|.{{SmartCardConnection/[[transactionState]]}}'s
              [=transaction state/promise=].</li>
            <li>If |connection|.{{SmartCardConnection/[[comm]]}} is `null`:
              <ol>
                <li>[=Reject=] |transactionPromise| with a "{{InvalidStateError}}"
                  {{DOMException}}.</li>
                <li>Set
                  |connection|.{{SmartCardConnection/[[transactionState]]}} to
                  `null`.</li>
                <li>Return.</li>
              </ol>
            </li>
            <li>Set
              |connection|.{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
              to `true`.</li>
            <li>Run the following steps [=in parallel=]:
              <ol>
                <li>Call
                  [=this=].{{SmartCardConnection/[[comm]]}}.`EndTransaction()` with
                  a `DWORD` corresponding to |disposition| as input parameter.</li>
                <li>Let |responseCode:RESPONSECODE| be the returned [[PCSC5]]
                  `RESPONSECODE`.</li>
                <li>[=Queue a global task=] on the [=relevant global object=] of
                  [=this=] using the [=smart card task source=] which performs
                  the following steps:
                  <ol>
                    <li>[=Clear the operationInProgress=] of
                      |connection|.{{SmartCardConnection/[[context]]}}.</li>
                    <li>Let |exception| be
                      |connection|.{{SmartCardConnection/[[transactionState]]}}'s
                      [=transaction state/pendingException=].</li>
                    <li>If |exception| is `null`, perform the following steps:
                      <ol>
                        <li>If |responseCode| is `SCARD_S_SUCCESS`,
                          [=resolve=] |transactionPromise|.</li>
                        <li>Otherwise, [=reject=] |transactionPromise| with an
                          [=exception=] {{SmartCardError/corresponding}} to
                          |responseCode|.</li>
                      </ol>
                    </li>
                    <li>Otherwise, [=reject=] |transactionPromise| with
                      |exception|.</li>
                    <li>Set
                      |connection|.{{SmartCardConnection/[[transactionState]]}}
                      to `null`.</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>

          <p>To <dfn>end any settled transaction</dfn> of a
          {{SmartCardConnection}} |connection:SmartCardConnection|, perform the
          following steps:</p>
          <ol>
            <li>If |connection|.{{SmartCardConnection/[[transactionState]]}} is
            `null`, abort these steps.</li>
            <li>Let |disposition| be
              |connection|.{{SmartCardConnection/[[transactionState]]}}'s
              [=transaction state/pendingDisposition=].</li>
            <li>If |disposition| is `null`, abort these steps.</li>
            <li>Set |connection|.{{SmartCardConnection/[[transactionState]]}}'s
              [=transaction state/pendingDisposition=] to `null`.</li>
            <li>[=End the transaction=] of |connection| with |disposition|.</li>
          </ol>

          <p>To <dfn>cancel</dfn> outstanding [[PCSC5]] `SCARDCOMM` operations,
          call [=this=].{{SmartCardConnection/[[comm]]}}.`Cancel()`.</p>
        </section>
      </section>
      <section>
        <h3><dfn>status()</dfn> method</h3>
        <p>The {{SmartCardConnection/status()}} method steps are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Let |pcscReader:array of STR| be an empty `STR[]`.</li>
              <li>Let |pcscState:DWORD| be a [[PCSC5]] `DWORD` set to `0`.</li>
              <li>Let |activeProtocol:DWORD| be a [[PCSC5]] `DWORD` set to `0`.</li>
              <li>Let |pcscAtr:array of BYTE| be a `BYTE[]` big enough to hold
                any [[ISO7186-3]] Answer To Reset (ATR).</li>
              <li>Call [=this=].{{SmartCardConnection/[[comm]]}}.`Status()`
                with |pcscReader|, |pcscState|, |activeProtocol| and |pcscAtr| as
                output parameters.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of
                    [=this=].{{SmartCardConnection/[[context]]}}.</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, [=reject=]
                    |promise| with an [=exception=]
                    {{SmartCardError/corresponding}} to |responseCode| and abort
                    these steps.</li>
                  <li>Let |state:SmartCardConnectionState| be a
                    {{SmartCardConnectionState}}
                    [=SmartCardConnectionState/corresponding=] to |pcscState|
                    and |activeProtocol|.</li>
                  <li>If |state| is {{undefined}}, [=reject=] |promise| with an
                    "{{UnknownError}}" {{DOMException}} and abort these steps.</li>
                  <li>Let |status:SmartCardConnectionStatus| be a new
                    {{SmartCardConnectionStatus}}.</li>
                  <li>Set |status|["{{SmartCardConnectionStatus/readerName}}"]
                    to |pcscReader|.</li>
                  <li>Set |status|["{{SmartCardConnectionStatus/state}}"]
                    to |state|.</li>
                  <li>Set
                    |status|["{{SmartCardConnectionStatus/answerToReset}}"] to
                    an {{ArrayBuffer}} with the bytes that were written to
                    |pcscAtr|.</li>
                  <li>[=Resolve=] |promise| with |status|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
        <section data-dfn-for="SmartCardConnectionStatus">
          <h4><dfn>SmartCardConnectionStatus</dfn> dictionary</h3>
          <pre class="idl">
            dictionary SmartCardConnectionStatus {
              required DOMString readerName;
              required SmartCardConnectionState state;
              ArrayBuffer answerToReset;
            };
          </pre>
          <dl>
            <dt><dfn>readerName</dfn> member</dt>
            <dd>Name of the connected reader.</dd>
            <dt><dfn>state</dfn> member</dt>
            <dd>Current state of the connection.</dd>
            <dt><dfn>answerToReset</dfn> member</dt>
            <dd>The answer to reset (ATR) string from the card, if applicable.</dd>
          </dl>
          <section data-dfn-for="SmartCardConnectionState">
            <h5><dfn>SmartCardConnectionState</dfn> enum</h3>
            <pre class="idl">
              enum SmartCardConnectionState {
                "absent",
                "present",
                "swallowed",
                "powered",
                "negotiable",
                "t0",
                "t1",
                "raw"
              };
            </pre>
            <dl>
              <dt><dfn>absent</dfn></dt>
              <dd>There is no card in the reader.</dd>
              <dt><dfn>present</dfn></dt>
              <dd>There is a card in the reader, but it has not been moved into
                position for use.</dd>
              <dt><dfn>swallowed</dfn></dt>
              <dd>There is a card in the reader in position for use. The card is
                not powered.</dd>
              <dt><dfn>powered</dfn></dt>
              <dd>Power is being provided to the card, but the reader driver is
                unaware of the mode of the card.</dd>
              <dt><dfn>negotiable</dfn></dt>
              <dd>The card has been reset and is awaiting PTS (protocol type
                selection) negotiation.</dd>
              <dt><dfn>t0</dfn></dt>
              <dd>The card is in [[ISO7186-3]] T=0 protocol mode and a new protocol
                may not be negotiated.</dd>
              <dt><dfn>t1</dfn></dt>
              <dd>The card is in [[ISO7186-3]] T=1 protocol mode and a new protocol
                may not be negotiated.</dd>
              <dt><dfn>raw</dfn></dt>
              <dd>The card is in raw protocol mode and a new protocol may not be
                negotiated.</dd>
            </dl>

            <p>Given a [[PCSC5]] `DWORD` |pcscState:DWORD| and a `DWORD`
            |activeProtocol:DWORD|, a
            <dfn data-dfn-for="SmartCardConnectionState">corresponding</dfn>
            {{SmartCardConnectionState}} is created with the following steps:</p>
            <ol>
              <li>If |pcscState| is [[PCSC5]] `SCARD_ABSENT`, return
                "{{SmartCardConnectionState/absent}}".</li>
              <li>If |pcscState| is [[PCSC5]] `SCARD_PRESENT`, return
                "{{SmartCardConnectionState/present}}".</li>
              <li>If |pcscState| is [[PCSC5]] `SCARD_SWALLOWED`, return
                "{{SmartCardConnectionState/swallowed}}".</li>
              <li>If |pcscState| is [[PCSC5]] `SCARD_POWERED`, return
                "{{SmartCardConnectionState/powered}}".</li>
              <li>If |pcscState| is [[PCSC5]] `SCARD_NEGOTIABLE`, return
                "{{SmartCardConnectionState/negotiable}}".</li>
              <li>If |pcscState| is [[PCSC5]] `SCARD_SPECIFIC`, perform the
                following steps:
                <ol>
                  <li>If |activeProtocol| is [[PCSC5]] `SCARD_PROTOCOL_T0`,
                    return "{{SmartCardConnectionState/t0}}".</li>
                  <li>If |activeProtocol| is [[PCSC5]] `SCARD_PROTOCOL_T1`,
                    return "{{SmartCardConnectionState/t1}}".</li>
                  <li>If |activeProtocol| is [[PCSC5]] `SCARD_PROTOCOL_RAW`,
                    return "{{SmartCardConnectionState/raw}}".</li>
                </ol>
              </li>
              <li>Return {{undefined}}.</li>
            </ol>
          </section>
        </section>
      </section>
      <section>
        <h3><dfn>control()</dfn> method</h3>
        <p>The {{SmartCardConnection/control(controlCode, data)}} method steps are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Let |pcscControlCode:DWORD| be a [[PCSC5]] `DWORD` containing
            |controlCode|.</li>
          <li>[=Get a copy of the buffer source=] |data:BufferSource| and save
            the result in a [[PCSC5]] `BYTE[]` |inBuffer:array of BYTE|.</li>
          <li>Let |outBuffer:array of BYTE| be a [[PCSC5]] `BYTE[]` large enough
          to hold any control command response.</li>
          <li>Let |outBufferLength:DWORD| be a `DWORD` set to `0`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Call [=this=].{{SmartCardConnection/[[comm]]}}.`Control()`
                with |pcscControlCode|, |inBuffer|, |outBuffer| and
                |outBufferLength| as arguments.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of
                    [=this=].{{SmartCardConnection/[[context]]}}.</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, [=reject=]
                    |promise| with an [=exception=]
                    {{SmartCardError/corresponding}} to |responseCode| and abort
                    these steps.</li>
                  <li>Let |resultBytes:byte sequence| be the first
                    |outBufferLength| bytes of |outBuffer|.</li>
                  <li>[=Resolve=] |promise| with the result of
                    [=ArrayBuffer/Create|creating=] an {{ArrayBuffer}} from
                    |resultBytes| in [=this=]'s [=relevant Realm=].</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
      </section>
      <section>
        <h3><dfn>getAttribute()</dfn> method</h3>
        <p>The {{SmartCardConnection/getAttribute(tag)}} method steps are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Let |pcscTag:DWORD| be a [[PCSC5]] `DWORD` containing |tag|.</li>
              <li>Let |buffer:array of BYTE| be a [[PCSC5]] `BYTE[]` large
                enough to hold this reader attribute, as determined by the
                platform's [[PCSC5]] implementation.</li>
              <li>Call [=this=].{{SmartCardConnection/[[comm]]}}.`GetReaderCapabilities()`
                with |pcscTag| and |buffer| as arguments.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of
                    [=this=].{{SmartCardConnection/[[context]]}}.</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, [=reject=]
                    |promise| with an [=exception=]
                    {{SmartCardError/corresponding}} to |responseCode| and abort
                    these steps.</li>
                  <li>Let |resultBytes:byte sequence| be the bytes of |buffer|
                    containing the attribute read.</li>
                  <li>[=Resolve=] |promise| with the result of
                    [=ArrayBuffer/Create|creating=] an {{ArrayBuffer}} from
                    |resultBytes| in [=this=]'s [=relevant Realm=].</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
        <aside class="note" title="Output buffer size">
          <p>Known [[PCSC5]] platform implementations allow either the output
          buffer to be automatically allocated or to query the size needed for
          it. This covers the gap left by [[PCSC5]] in that regard.</p>
        </aside>
      </section>
      <section>
        <h3><dfn>setAttribute()</dfn> method</h3>
        <p>The {{SmartCardConnection/setAttribute(tag, value)}} method steps are:</p>
        <ol>
          <li>Let |promise:Promise| be [=a new promise=].</li>
          <li>If
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            is `true`, [=reject=] |promise| with a "{{InvalidStateError}}"
          {{DOMException}} and return |promise|.</li>
          <li>If [=this=].{{SmartCardConnection/[[comm]]}} is `null`, [=reject=]
            |promise| with a "{{InvalidStateError}}" {{DOMException}} and return
            |promise|.</li>
          <li>Set
            [=this=].{{SmartCardConnection/[[context]]}}.{{SmartCardContext/[[operationInProgress]]}}
            to `true`.</li>
          <li>Let |pcscTag:DWORD| be a [[PCSC5]] `DWORD` containing
            |tag|.</li>
          <li>[=Get a copy of the buffer source=] |value:BufferSource| and save
            the result in a [[PCSC5]] `BYTE[]` |buffer:array of BYTE|.</li>
          <li>Run the following steps [=in parallel=]:
            <ol>
              <li>Call
                [=this=].{{SmartCardConnection/[[comm]]}}.`SetReaderCapabilities()`
                with |pcscTag| and |buffer| as arguments.</li>
              <li>Let |responseCode:RESPONSECODE| be the returned
                `RESPONSECODE`.</li>
              <li>[=Queue a global task=] on the [=relevant global object=] of
                [=this=] using the [=smart card task source=] which performs the
                following steps:
                <ol>
                  <li>[=Clear the operationInProgress=] of
                    [=this=].{{SmartCardConnection/[[context]]}}.</li>
                  <li>If |responseCode| is not `SCARD_S_SUCCESS`, [=reject=]
                    |promise| with an [=exception=]
                    {{SmartCardError/corresponding}} to |responseCode| and abort
                    these steps.</li>
                  <li>[=Resolve=] |promise|.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return |promise|.</li>
        </ol>
      </section>
    </section>

    <section data-dfn-for="SmartCardError">
      <h2><dfn>SmartCardError</dfn> interface</h2>
      <pre class="idl">
        [Exposed=(DedicatedWorker, SharedWorker, Window), Serializable]
        interface SmartCardError : DOMException {
          constructor(optional DOMString message = "", SmartCardErrorOptions options);
          readonly attribute SmartCardResponseCode responseCode;
        };
      </pre>
      <p>The <dfn>responseCode</dfn> attribute is the error or warning response
      code returned by the related [[PCSC5]] method.</p>
      <p>Given a [[PCSC5]] `RESPONSECODE` different from `SCARD_S_SUCCESS`, a
      <dfn data-dfn-for="SmartCardError">corresponding</dfn> [=exception=] is
      created with the following steps:</p>
      <aside class="note" title="Unspecified response codes">
        <p>The following `RESPONSECODE`s are not part of [[PCSC5]] but are still
        considered in this specification as existing PC/SC
        implementations use them:</p>
        <ul>
          <li>`SCARD_E_SERVER_TOO_BUSY`</li>
          <li>`SCARD_E_SERVICE_STOPPED`</li>
          <li>`SCARD_P_SHUTDOWN`</li>
        </ul>
      </aside>
      <ol>
        <li>Let |pcscCode:RESPONSECODE| be that `RESPONSECODE`.</li>
        <li>If |pcscCode| is `SCARD_E_NO_SERVICE`, return a [=new=]
          {{SmartCardResponseCode/"no-service"}} {{SmartCardError}}.
          <aside class="note" title="Creating SmartCardError instances">
            <p>In statements such as:</p>
            <blockquote>[=new=] {{SmartCardResponseCode/"no-service"}}
              {{SmartCardError}}</blockquote>
            <p>What is meant, more exactly, is:</p>
            <blockquote>[=new=] {{SmartCardError}} where
              {{SmartCardError/responseCode}} is set to
              {{SmartCardResponseCode/"no-service"}}</blockquote>
          </aside>
        </li>
        <li>If |pcscCode| is `SCARD_E_NO_SMARTCARD`, return a [=new=]
          {{SmartCardResponseCode/"no-smartcard"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_NOT_READY`, return a [=new=]
          {{SmartCardResponseCode/"not-ready"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_NOT_TRANSACTED`, return a [=new=]
          {{SmartCardResponseCode/"not-transacted"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_PROTO_MISMATCH`, return a [=new=]
          {{SmartCardResponseCode/"proto-mismatch"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_READER_UNAVAILABLE`, return a [=new=]
          {{SmartCardResponseCode/"reader-unavailable"}}
          {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_W_REMOVED_CARD`, return a [=new=]
          {{SmartCardResponseCode/"removed-card"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_W_RESET_CARD`, return a [=new=]
          {{SmartCardResponseCode/"reset-card"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_SERVER_TOO_BUSY`, return a [=new=]
          {{SmartCardResponseCode/"server-too-busy"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_SHARING_VIOLATION`, return a [=new=]
          {{SmartCardResponseCode/"sharing-violation"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_SYSTEM_CANCELLED`, return a [=new=]
          {{SmartCardResponseCode/"system-cancelled"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_UNKNOWN_READER`, return a [=new=]
          {{SmartCardResponseCode/"unknown-reader"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_W_UNPOWERED_CARD`, return a [=new=]
          {{SmartCardResponseCode/"unpowered-card"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_W_UNRESPONSIVE_CARD`, return a [=new=]
          {{SmartCardResponseCode/"unresponsive-card"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_W_UNSUPPORTED_CARD`, return a [=new=]
          {{SmartCardResponseCode/"unsupported-card"}} {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_UNSUPPORTED_FEATURE`, return a [=new=]
          {{SmartCardResponseCode/"unsupported-feature"}}
          {{SmartCardError}}.</li>
        <li>If |pcscCode| is `SCARD_E_INVALID_PARAMETER`, return a [=new=]
          {{TypeError}}.</li>
        <li>If |pcscCode| is `SCARD_E_INVALID_HANDLE`, return a [=new=]
          "{{InvalidStateError}}" {{DOMException}}.</li>
        <li>If |pcscCode| is `SCARD_E_SERVICE_STOPPED`, return a [=new=]
          "{{InvalidStateError}}" {{DOMException}}.</li>
        <li>If |pcscCode| is `SCARD_P_SHUTDOWN`, return a [=new=]
          "{{AbortError}}" {{DOMException}}.</li>
        <li>Otherwise return a [=new=] "{{UnknownError}}" {{DOMException}}.</li>
      </ol>
      <section data-dfn-for="SmartCardErrorOptions">
        <h3><dfn>SmartCardErrorOptions</dfn> dictionary</h3>
        <pre class="idl">
          dictionary SmartCardErrorOptions {
            required SmartCardResponseCode responseCode;
          };
        </pre>
        <p>The <dfn>responseCode</dfn> member is the value for {{SmartCardError}}'s
        {{SmartCardError/responseCode}} attribute.</p>
      </section>
      <section data-dfn-for="SmartCardResponseCode">
        <h3><dfn>SmartCardResponseCode</dfn> enum</h3>
        <pre class="idl">
          enum SmartCardResponseCode {
            "no-service",
            "no-smartcard",
            "not-ready",
            "not-transacted",
            "proto-mismatch",
            "reader-unavailable",
            "removed-card",
            "reset-card",
            "server-too-busy",
            "sharing-violation",
            "system-cancelled",
            "unknown-reader",
            "unpowered-card",
            "unresponsive-card",
            "unsupported-card",
            "unsupported-feature"
          };
        </pre>
        <dl>
          <dt><dfn>no-service</dfn></dt>
          <dd>SCARD_E_NO_SERVICE in the [[PCSC5]] spec.</dd>
          <dt><dfn>no-smartcard</dfn></dt>
          <dd>SCARD_E_NO_SMARTCARD in the [[PCSC5]] spec.</dd>
          <dt><dfn>not-ready</dfn></dt>
          <dd>SCARD_E_NOT_READY in the [[PCSC5]] spec.</dd>
          <dt><dfn>not-transacted</dfn></dt>
          <dd>SCARD_E_NOT_TRANSACTED in the [[PCSC5]] spec.</dd>
          <dt><dfn>proto-mismatch</dfn></dt>
          <dd>SCARD_E_PROTO_MISMATCH in the [[PCSC5]] spec.</dd>
          <dt><dfn>reader-unavailable</dfn></dt>
          <dd>SCARD_E_READER_UNAVAILABLE in the [[PCSC5]] spec.</dd>
          <dt><dfn>removed-card</dfn></dt>
          <dd>SCARD_W_REMOVED_CARD in the [[PCSC5]] spec.</dd>
          <dt><dfn>reset-card</dfn></dt>
          <dd>SCARD_W_RESET_CARD in the [[PCSC5]] spec.</dd>
          <dt><dfn>server-too-busy</dfn></dt>
          <dd>The smart card resource manager is too busy to complete this operation.</dd>
          <dt><dfn>sharing-violation</dfn></dt>
          <dd>SCARD_E_SHARING_VIOLATION in the [[PCSC5]] spec.</dd>
          <dt><dfn>system-cancelled</dfn></dt>
          <dd>SCARD_E_SYSTEM_CANCELLED in the [[PCSC5]] spec.</dd>
          <dt><dfn>unknown-reader</dfn></dt>
          <dd>SCARD_E_UNKNOWN_READER in the [[PCSC5]] spec.</dd>
          <dt><dfn>unpowered-card</dfn></dt>
          <dd>SCARD_W_UNPOWERED_CARD in the [[PCSC5]] spec.</dd>
          <dt><dfn>unresponsive-card</dfn></dt>
          <dd>SCARD_W_UNRESPONSIVE_CARD in the [[PCSC5]] spec.</dd>
          <dt><dfn>unsupported-card</dfn></dt>
          <dd>SCARD_W_UNSUPPORTED_CARD in the [[PCSC5]] spec.</dd>
          <dt><dfn>unsupported-feature</dfn></dt>
          <dd>SCARD_E_UNSUPPORTED_FEATURE in the [[PCSC5]] spec.</dd>
        </dl>
      </section>
    </section>
    <section id="integrations">
      <h2>Integrations</h2>

      <section id="permissions-policy">
        <h3>Permissions Policy</h3>

        <p>This specification defines a feature that controls whether the
        methods exposed by the {{Navigator/smartCard}} attribute on the
        {{Navigator}} object may be used.</p>

        <p>The feature name for this feature is
        "<dfn data-dfn-for="policy-controlled feature">smart-card</dfn>".</p>

        <p>The [=policy-controlled feature/default allowlist=] for this feature
        is `'self'`.</p>
      </section>
    </section>
    <section id='conformance'>
      <!-- This section is filled automatically by ReSpec. -->
    </section>
  </body>
</html>
